package npg_seq_melt::archive::top_up;

use Moose;
use MooseX::StrictConstructor;
use namespace::autoclean;
use Readonly;
use Carp;
use English qw(-no_match_vars);
use Pod::Usage;
use IO::File;
use File::Slurp;

use npg_tracking::glossary::composition;

extends qw{npg_seq_melt::query::top_up};

with qw{
     npg_common::roles::log
};

our $VERSION = '0';
Readonly::Scalar my $WR_PRIORITY  => 51;
Readonly::Scalar my $MEMORY_4000M => q[4000M];


=head1 NAME

    npg_seq_melt::archive::top_up

=head1 SYNOPSIS

npg_seq_melt::archive::top_up->new( xxx => yyy, dry_run => 1)->run;


=head1 SUBROUTINES/METHODS

=head2 rt_ticket

For use with --label with npg_pipeline_post_qc_review rt$rt_ticket

=cut

has 'rt_ticket'     => ( isa           => 'Int',
                         is            => 'ro',
                         required      => 1,
                         documentation => q[RT ticket for batch processed],
);


=head2 wr_deployment

production or developmet

=cut

has 'wr_deployment'  => ( isa           => 'Str',
                          is            => 'ro',
                          default       => 'production',
                          documentation => q[ For use with wr --deployment option (production or development) ],
);

=head2 commands_file

File name to write wr commands to

=cut

has 'commands_file' => ( isa           => 'Str',
                         is            => 'ro',
                         default       => q[/tmp/wr_archive_cmds.txt],

                         documentation => 'File name to write wr commands to',
    );


=head2 wr_env

=cut


has 'wr_env'  => (isa  => 'Str',
                  is   => 'ro',
                  documentation => 'Environment to find relevant scripts and files. NPG_REPOSITORY_ROOT=, REF_PATH=,PATH=,PERL5LIB=',
);


=head2 supplier_sample 

=cut

has 'supplier_sample' => ( isa           => 'Str',
                           is            => 'rw',
                           documentation => 'Sequencescape supplier sample name',
    );


=head2 composition_id 

=cut

has 'composition_id' => ( isa           => 'Str',
                          is            => 'rw',
                           documentation => 'Composition id from npg_pipeline::product file_name_root',
    );


=head2 out_dir 

=cut

#has 'out_dir' => ( isa           => 'Str',
#                   is            => 'rw',
#                   documentation => 'Results cache name derived from merge_component_cache_dir name',
#    );


=head2 rpt_list

Semi-colon separated list of run:position or run:position:tag for the same sample
that define a composition for this merge. An optional attribute.

=cut

has 'rpt_list' => (
     isa           => q[ArrayRef[Str]],
     is            => q[ro],
     predicate     => q[has_rpt_list],
     );

=head2 composition_path

=cut

has 'composition_path' => ( isa           => 'ArrayRef',
                            is            => 'ro',
                            documentation => 'paths with composition.json file for top-up merged data',
                            predicate     => q[has_composition_path],
    );


=head2 compositions

=cut

has 'compositions' => ( isa               => q[ArrayRef[npg_tracking::glossary::composition]],
                        is                => q[rw],
                        documentation     => q[],
                        lazy_build        => 1
                      );


sub _build_compositions{ 
 my $self = shift;
 my @compositions = ();
  if ($self->has_rpt_list) {
    my $class = 'npg_tracking::glossary::composition::factory::rpt_list';
    @compositions = map { $_->create_composition() }
                    map { $class->new(rpt_list => $_) }
                    @{$self->rpt_list()};
  } elsif ($self->has_composition_path) { print $self->composition_path,"+++++\n";
    @compositions = map { npg_tracking::glossary::composition->thaw($_) }
                    map { read_file $_ }
                    glob( join q[ ],
                    map { "$_/*.composition.json" }
                    @{$self->composition_path} );
use Data::Dumper; print Dumper @compositions ;
  }
return \@compositions;
}

=head2 can_run

=cut

sub can_run {
    my $self = shift;
#    if (! $self->repository){ $self->log('NPG_REPOSITORY_ROOT or --repository not specified') ; return 0 };
    ### return 0 if previous submission for this 
     # $self->run_query();


return 1;
}

=head2 run

=cut

sub run {
    my $self = shift;

    return 0 if ! $self->can_run();
    $self->make_commands();
    $self->run_wr();
    return 1;
}


=head2 make_commands

=cut

sub make_commands {
    my $self = shift;



####export CLASSPATH=/software/npg/20190626/jars;export NPG_CACHED_SAMPLESHEET_FILE=/lustre/scratch113/merge_component_results/5392/48/bc/48bc99bfddb379ea9569037c9054d3a03a7a0aaa8fe82804e0f317991e501b95/48bc99bfddb379ea9569037c9054d3a03a7a0aaa8fe82804e0f317991e501b95.csv;export NPG_REPOSITORY_ROOT=/lustre/scratch113/npg_repository;export PATH=/software/npg/20190809/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin;export PERL5LIB=/software/npg/20190809/lib/perl5; umask 002 && npg_pipeline_post_qc_review  --verbose  --function_order archive_to_s3 --function_order notify_product_delivery --label rt668088 --runfolder_path /lustre/scratch113/tickets/rt668088/logs/48bc99bfddb379ea9569037c9054d3a03a7a0aaa8fe82804e0f317991e501b95 --archive_path /lustre/scratch113/merge_component_results/5392/48/bc/ --product_rpt_list '27312:1:15;27312:2:15;27312 :3:15;27312:4:15;28780:2:5' --analysis_path /lustre/scratch113/tickets/rt668088/logs/48bc99bfddb379ea9569037c9054d3a03a7a0aaa8fe82804e0f317991e501b95 --function_order update_ml_warehouse

my $command_input_fh = IO::File->new($self->commands_file,'>') or croak q[cannot open ], $self->commands_file," : $OS_ERROR\n";

my $cmd = q[];

$self->_command_to_json({
                         cmd      => $cmd,
                         disk     => 150,
                         },q[],$command_input_fh);



return;
}

=head2 _command_to_json

=cut

sub _command_to_json {
    my $self     = shift;
    my $hr       = shift;
    my $analysis = shift;
    my $command_fh = shift;

       $hr->{priority} = $WR_PRIORITY;
    my $cmd = $hr->{cmd};
    my $out_dir = $self->out_dir;
    my $composition_id = $self->composition_id;
    my $out_file_path = $self->out_dir . q[/log/] . $self->composition_id;
       if ($analysis && ($analysis !~ /^_/smx)){ $out_file_path .= q[.] };
       $out_file_path .= $analysis ? $analysis : q[];
       $out_file_path .= q[.out];


       $hr->{cmd} = qq[($cmd) 2>&1 | tee -a \"$out_file_path\"];

       if (! $hr->{memory}){ $hr->{memory} = $MEMORY_4000M };
    my $json = JSON->new->allow_nonref;
    my $json_text   = $json->encode($hr);

    print {$command_fh} $json_text,"\n"  or $self->log(qq[Can't write to commands file: $ERRNO]);;
return;
}


=head2 run_wr

=cut

sub run_wr {
    my $self = shift;

    my $wr_cmd = q[wr  add --cwd /tmp --retries 0  --override 2 --disk 0 --rep_grp top_up_merge --env '];
       $wr_cmd .= $self->wr_env();
       $wr_cmd .= q[' -f ] . $self->commands_file;
       $wr_cmd .= q[ --deployment ] . $self->wr_deployment;


    $self->log("**Running $wr_cmd**");

   if (! $self->dry_run ){
     my $wr_fh = IO::File->new("$wr_cmd |") or die "cannot run cmd\n";
     while(<$wr_fh>){}
     $wr_fh->close();
}

    return 1;
}


__PACKAGE__->meta->make_immutable;

1;

__END__


=head1 DESCRIPTION

=head1 DIAGNOSTICS

=head1 CONFIGURATION AND ENVIRONMENT

=head1 DEPENDENCIES

=over

=item Carp

=item Moose

=item MooseX::StrictConstructor

=item Moose::Meta::Class

=item namespace::autoclean

=item Readonly

=item IO::File 

=item English

=item File::Slurp

=back

=head1 INCOMPATIBILITIES

=head1 BUGS AND LIMITATIONS

=head1 AUTHOR

Jillian Durham

=head1 LICENSE AND COPYRIGHT

Copyright (C) 2019 Genome Research Ltd

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

